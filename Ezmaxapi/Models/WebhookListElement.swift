//
// WebhookListElement.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

/** A Webhook List Element */
public struct WebhookListElement: Codable, JSONEncodable, Hashable {

    public static let sWebhookUrlRule = StringRule(minLength: nil, maxLength: nil, pattern: "/^(https|http):\/\/[^\\s\/$.?#].[^\\s]*$/")
    /** The unique ID of the Webhook */
    public var pkiWebhookID: Int
    /** The description of the Webhook */
    public var sWebhookDescription: String
    /** The URL of the Webhook callback */
    public var sWebhookUrl: String
    /** The concatenated string to describe the Webhook event */
    public var sWebhookEvent: String
    /** The email that will receive the Webhook in case all attempts fail */
    public var sWebhookEmailfailed: String
    public var eWebhookModule: FieldEWebhookModule
    public var eWebhookEzsignevent: FieldEWebhookEzsignevent?
    public var eWebhookManagementevent: FieldEWebhookManagementevent?
    /** Whether the Webhook is active or not */
    public var bWebhookIsactive: Bool
    /** Whether the requests will be signed or not */
    public var bWebhookIssigned: Bool

    public init(pkiWebhookID: Int, sWebhookDescription: String, sWebhookUrl: String, sWebhookEvent: String, sWebhookEmailfailed: String, eWebhookModule: FieldEWebhookModule, eWebhookEzsignevent: FieldEWebhookEzsignevent? = nil, eWebhookManagementevent: FieldEWebhookManagementevent? = nil, bWebhookIsactive: Bool, bWebhookIssigned: Bool) {
        self.pkiWebhookID = pkiWebhookID
        self.sWebhookDescription = sWebhookDescription
        self.sWebhookUrl = sWebhookUrl
        self.sWebhookEvent = sWebhookEvent
        self.sWebhookEmailfailed = sWebhookEmailfailed
        self.eWebhookModule = eWebhookModule
        self.eWebhookEzsignevent = eWebhookEzsignevent
        self.eWebhookManagementevent = eWebhookManagementevent
        self.bWebhookIsactive = bWebhookIsactive
        self.bWebhookIssigned = bWebhookIssigned
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case pkiWebhookID
        case sWebhookDescription
        case sWebhookUrl
        case sWebhookEvent
        case sWebhookEmailfailed
        case eWebhookModule
        case eWebhookEzsignevent
        case eWebhookManagementevent
        case bWebhookIsactive
        case bWebhookIssigned
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(pkiWebhookID, forKey: .pkiWebhookID)
        try container.encode(sWebhookDescription, forKey: .sWebhookDescription)
        try container.encode(sWebhookUrl, forKey: .sWebhookUrl)
        try container.encode(sWebhookEvent, forKey: .sWebhookEvent)
        try container.encode(sWebhookEmailfailed, forKey: .sWebhookEmailfailed)
        try container.encode(eWebhookModule, forKey: .eWebhookModule)
        try container.encodeIfPresent(eWebhookEzsignevent, forKey: .eWebhookEzsignevent)
        try container.encodeIfPresent(eWebhookManagementevent, forKey: .eWebhookManagementevent)
        try container.encode(bWebhookIsactive, forKey: .bWebhookIsactive)
        try container.encode(bWebhookIssigned, forKey: .bWebhookIssigned)
    }
}

