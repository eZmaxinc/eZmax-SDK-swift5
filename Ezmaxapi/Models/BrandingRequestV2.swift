//
// BrandingRequestV2.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

/** A Branding Object */
public struct BrandingRequestV2: Codable, JSONEncodable, Hashable {

    public static let pkiBrandingIDRule = NumericRule<Int>(minimum: 0, exclusiveMinimum: false, maximum: nil, exclusiveMaximum: false, multipleOf: nil)
    public static let iBrandingColorRule = NumericRule<Int>(minimum: 0, exclusiveMinimum: false, maximum: 16777215, exclusiveMaximum: false, multipleOf: nil)
    public static let sBrandingNameRule = StringRule(minLength: nil, maxLength: nil, pattern: "/^.{0,55}$/")
    public static let sEmailAddressRule = StringRule(minLength: nil, maxLength: nil, pattern: "/^[\\w.%+\\-!#$%&'*+\/=?^`{|}~]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,20}$/")
    /** The unique ID of the Branding */
    public var pkiBrandingID: Int?
    public var objBrandingDescription: MultilingualBrandingDescription
    public var eBrandingLogo: FieldEBrandingLogo
    public var eBrandingAlignlogo: FieldEBrandingAlignlogo?
    /** The Base64 encoded binary content of the branding logo. This need to match image type selected in eBrandingLogo if you supply an image. If you select 'Default', the logo will be deleted and the default one will be used. */
    public var sBrandingBase64: Data?
    /** The primary color. This is a RGB color converted into integer */
    public var iBrandingColor: Int
    /** The name of the Branding  This value will only be set if you wish to overwrite the default name. If you want to keep the default name, leave this property empty */
    public var sBrandingName: String?
    /** The email address. */
    public var sEmailAddress: String?
    /** Whether the Branding is active or not */
    public var bBrandingIsactive: Bool

    public init(pkiBrandingID: Int? = nil, objBrandingDescription: MultilingualBrandingDescription, eBrandingLogo: FieldEBrandingLogo, eBrandingAlignlogo: FieldEBrandingAlignlogo? = nil, sBrandingBase64: Data? = nil, iBrandingColor: Int, sBrandingName: String? = nil, sEmailAddress: String? = nil, bBrandingIsactive: Bool) {
        self.pkiBrandingID = pkiBrandingID
        self.objBrandingDescription = objBrandingDescription
        self.eBrandingLogo = eBrandingLogo
        self.eBrandingAlignlogo = eBrandingAlignlogo
        self.sBrandingBase64 = sBrandingBase64
        self.iBrandingColor = iBrandingColor
        self.sBrandingName = sBrandingName
        self.sEmailAddress = sEmailAddress
        self.bBrandingIsactive = bBrandingIsactive
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case pkiBrandingID
        case objBrandingDescription
        case eBrandingLogo
        case eBrandingAlignlogo
        case sBrandingBase64
        case iBrandingColor
        case sBrandingName
        case sEmailAddress
        case bBrandingIsactive
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encodeIfPresent(pkiBrandingID, forKey: .pkiBrandingID)
        try container.encode(objBrandingDescription, forKey: .objBrandingDescription)
        try container.encode(eBrandingLogo, forKey: .eBrandingLogo)
        try container.encodeIfPresent(eBrandingAlignlogo, forKey: .eBrandingAlignlogo)
        try container.encodeIfPresent(sBrandingBase64, forKey: .sBrandingBase64)
        try container.encode(iBrandingColor, forKey: .iBrandingColor)
        try container.encodeIfPresent(sBrandingName, forKey: .sBrandingName)
        try container.encodeIfPresent(sEmailAddress, forKey: .sEmailAddress)
        try container.encode(bBrandingIsactive, forKey: .bBrandingIsactive)
    }
}

