//
// VersionhistoryResponse.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

/** A Versionhistory Object */
public struct VersionhistoryResponse: Codable, JSONEncodable, Hashable {

    public static let pkiVersionhistoryIDRule = NumericRule<Int>(minimum: 0, exclusiveMinimum: false, maximum: nil, exclusiveMaximum: false, multipleOf: nil)
    public static let fkiModuleIDRule = NumericRule<Int>(minimum: 0, exclusiveMinimum: false, maximum: nil, exclusiveMaximum: false, multipleOf: nil)
    public static let fkiModulesectionIDRule = NumericRule<Int>(minimum: 0, exclusiveMinimum: false, maximum: nil, exclusiveMaximum: false, multipleOf: nil)
    /** The unique ID of the Versionhistory */
    public var pkiVersionhistoryID: Int
    /** The unique ID of the Module */
    public var fkiModuleID: Int?
    /** The unique ID of the Modulesection */
    public var fkiModulesectionID: Int?
    /** The Name of the Module in the language of the requester */
    public var sModuleNameX: String?
    /** The Name of the Modulesection in the language of the requester */
    public var sModulesectionNameX: String?
    public var eVersionhistoryUsertype: FieldEVersionhistoryUsertype?
    public var objVersionhistoryDetail: MultilingualVersionhistoryDetail
    /** The date  at which the Versionhistory was published or should be published */
    public var dtVersionhistoryDate: String
    /** The date  at which the Versionhistory will no longer be visible */
    public var dtVersionhistoryDateend: String?
    public var eVersionhistoryType: FieldEVersionhistoryType
    /** Whether the Versionhistory is published or still a draft */
    public var bVersionhistoryDraft: Bool

    public init(pkiVersionhistoryID: Int, fkiModuleID: Int? = nil, fkiModulesectionID: Int? = nil, sModuleNameX: String? = nil, sModulesectionNameX: String? = nil, eVersionhistoryUsertype: FieldEVersionhistoryUsertype? = nil, objVersionhistoryDetail: MultilingualVersionhistoryDetail, dtVersionhistoryDate: String, dtVersionhistoryDateend: String? = nil, eVersionhistoryType: FieldEVersionhistoryType, bVersionhistoryDraft: Bool) {
        self.pkiVersionhistoryID = pkiVersionhistoryID
        self.fkiModuleID = fkiModuleID
        self.fkiModulesectionID = fkiModulesectionID
        self.sModuleNameX = sModuleNameX
        self.sModulesectionNameX = sModulesectionNameX
        self.eVersionhistoryUsertype = eVersionhistoryUsertype
        self.objVersionhistoryDetail = objVersionhistoryDetail
        self.dtVersionhistoryDate = dtVersionhistoryDate
        self.dtVersionhistoryDateend = dtVersionhistoryDateend
        self.eVersionhistoryType = eVersionhistoryType
        self.bVersionhistoryDraft = bVersionhistoryDraft
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case pkiVersionhistoryID
        case fkiModuleID
        case fkiModulesectionID
        case sModuleNameX
        case sModulesectionNameX
        case eVersionhistoryUsertype
        case objVersionhistoryDetail
        case dtVersionhistoryDate
        case dtVersionhistoryDateend
        case eVersionhistoryType
        case bVersionhistoryDraft
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(pkiVersionhistoryID, forKey: .pkiVersionhistoryID)
        try container.encodeIfPresent(fkiModuleID, forKey: .fkiModuleID)
        try container.encodeIfPresent(fkiModulesectionID, forKey: .fkiModulesectionID)
        try container.encodeIfPresent(sModuleNameX, forKey: .sModuleNameX)
        try container.encodeIfPresent(sModulesectionNameX, forKey: .sModulesectionNameX)
        try container.encodeIfPresent(eVersionhistoryUsertype, forKey: .eVersionhistoryUsertype)
        try container.encode(objVersionhistoryDetail, forKey: .objVersionhistoryDetail)
        try container.encode(dtVersionhistoryDate, forKey: .dtVersionhistoryDate)
        try container.encodeIfPresent(dtVersionhistoryDateend, forKey: .dtVersionhistoryDateend)
        try container.encode(eVersionhistoryType, forKey: .eVersionhistoryType)
        try container.encode(bVersionhistoryDraft, forKey: .bVersionhistoryDraft)
    }
}

