//
// UserlogintypeResponse.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

/** An Userlogintype Object */
public struct UserlogintypeResponse: Codable, JSONEncodable, Hashable {

    static let pkiUserlogintypeIDRule = NumericRule<Int>(minimum: 0, exclusiveMinimum: false, maximum: nil, exclusiveMaximum: false, multipleOf: nil)
    /** The unique ID of the Userlogintype  Valid values:  |Value|Description|Detail| |-|-|-| |1|**Email Only**|The Ezsignsigner will receive a secure link by email| |2|**Email and phone or SMS**|The Ezsignsigner will receive a secure link by email and will need to authenticate using SMS or Phone call. **Additional fee applies**| |3|**Email and secret question**|The Ezsignsigner will receive a secure link by email and will need to authenticate using a predefined question and answer| |4|**In person only**|The Ezsignsigner will only be able to sign \"In-Person\" and there won't be any authentication. No email will be sent for invitation to sign. Make sure you evaluate the risk of signature denial and at minimum, we recommend you use a handwritten signature type| |5|**In person with phone or SMS**|The Ezsignsigner will only be able to sign \"In-Person\" and will need to authenticate using SMS or Phone call. No email will be sent for invitation to sign. **Additional fee applies**| */
    public var pkiUserlogintypeID: Int
    public var objUserlogintypeDescription: MultilingualUserlogintypeDescription
    /** The description of the Userlogintype in the language of the requester */
    public var sUserlogintypeDescriptionX: String

    public init(pkiUserlogintypeID: Int, objUserlogintypeDescription: MultilingualUserlogintypeDescription, sUserlogintypeDescriptionX: String) {
        self.pkiUserlogintypeID = pkiUserlogintypeID
        self.objUserlogintypeDescription = objUserlogintypeDescription
        self.sUserlogintypeDescriptionX = sUserlogintypeDescriptionX
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case pkiUserlogintypeID
        case objUserlogintypeDescription
        case sUserlogintypeDescriptionX
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(pkiUserlogintypeID, forKey: .pkiUserlogintypeID)
        try container.encode(objUserlogintypeDescription, forKey: .objUserlogintypeDescription)
        try container.encode(sUserlogintypeDescriptionX, forKey: .sUserlogintypeDescriptionX)
    }
}

