//
// WebhookResponse.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

/** A webhook object */
public struct WebhookResponse: Codable, JSONEncodable, Hashable {

    public enum EWebhookModule: String, Codable, CaseIterable {
        case ezsign = "Ezsign"
        case management = "Management"
    }
    public enum EWebhookEzsignevent: String, Codable, CaseIterable {
        case documentCompleted = "DocumentCompleted"
        case folderCompleted = "FolderCompleted"
    }
    public enum EWebhookManagementevent: String, Codable, CaseIterable {
        case userCreated = "UserCreated"
    }
    /** The customer code assigned to your account */
    public var pksCustomerCode: String
    /** The Webhook ID. This value is visible in the admin interface. */
    public var pkiWebhookID: Int
    /** The Module generating the Event. */
    public var eWebhookModule: EWebhookModule
    /** This Ezsign Event. This property will be set only if the Module is \"Ezsign\". */
    public var eWebhookEzsignevent: EWebhookEzsignevent?
    /** This Management Event. This property will be set only if the Module is \"Management\". */
    public var eWebhookManagementevent: EWebhookManagementevent?
    /** The url being called */
    public var sWebhookUrl: String
    /** Wheter the webhook received is a manual test or a real event */
    public var bWebhookTest: Bool
    /** Wheter the server's SSL certificate should be validated or not. Not recommended for production use. */
    public var bWebhookSkipsslvalidation: Bool
    /** The email that will receive the webhook in case all attempts fail. */
    public var sWebhookEmailfailed: String

    public init(pksCustomerCode: String, pkiWebhookID: Int, eWebhookModule: EWebhookModule, eWebhookEzsignevent: EWebhookEzsignevent? = nil, eWebhookManagementevent: EWebhookManagementevent? = nil, sWebhookUrl: String, bWebhookTest: Bool, bWebhookSkipsslvalidation: Bool, sWebhookEmailfailed: String) {
        self.pksCustomerCode = pksCustomerCode
        self.pkiWebhookID = pkiWebhookID
        self.eWebhookModule = eWebhookModule
        self.eWebhookEzsignevent = eWebhookEzsignevent
        self.eWebhookManagementevent = eWebhookManagementevent
        self.sWebhookUrl = sWebhookUrl
        self.bWebhookTest = bWebhookTest
        self.bWebhookSkipsslvalidation = bWebhookSkipsslvalidation
        self.sWebhookEmailfailed = sWebhookEmailfailed
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case pksCustomerCode
        case pkiWebhookID
        case eWebhookModule
        case eWebhookEzsignevent
        case eWebhookManagementevent
        case sWebhookUrl
        case bWebhookTest
        case bWebhookSkipsslvalidation
        case sWebhookEmailfailed
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(pksCustomerCode, forKey: .pksCustomerCode)
        try container.encode(pkiWebhookID, forKey: .pkiWebhookID)
        try container.encode(eWebhookModule, forKey: .eWebhookModule)
        try container.encodeIfPresent(eWebhookEzsignevent, forKey: .eWebhookEzsignevent)
        try container.encodeIfPresent(eWebhookManagementevent, forKey: .eWebhookManagementevent)
        try container.encode(sWebhookUrl, forKey: .sWebhookUrl)
        try container.encode(bWebhookTest, forKey: .bWebhookTest)
        try container.encode(bWebhookSkipsslvalidation, forKey: .bWebhookSkipsslvalidation)
        try container.encode(sWebhookEmailfailed, forKey: .sWebhookEmailfailed)
    }
}

